import { Log, PeprRequest, a } from "pepr";
import * as fs from 'fs';
import * as wasm from './wasm_exec.js';
// import './wasm_exec.js';

export class TransformerAPI {
  private go: any; // untyped autogenerated :(
  private ImageTransformHost: (targetHost: string, srcReference: string) => string; //Promise<string>;
  public async run(): Promise<void> {
    let wasmCode: Buffer
    try {
      wasmCode = fs.readFileSync('main.wasm');
      // this.go = new .Go();
      this.go = new wasm.Go();
    } catch (err) {
      Log.error("Error reading wasm file", err.toString());
    }

    

    try {
      const result = await wasm.WebAssembly.instantiate(wasmCode, this.go.importObject);
      this.go.run(result.instance);

      // Set the exported Go function as a callback
      this.ImageTransformHost = result.instance.exports.ImageTransformHost as (targetHost: string, srcReference: string) => string;
    } catch (err) {
      console.error(err);
    }
  }

  transformAllContainers(
    pod: PeprRequest<a.Pod>,
    address: string
  ) {
    if (pod.Raw?.spec?.initContainers !== undefined) {

      pod.Raw.spec.initContainers.map(container => {
        try {
          container.image = this.imageTransformHost(
            address,
            container.image
          );
        } catch (err) {
          Log.error("Error calling imageTransformHost", err.toString());
        }
      })

    }

    if (pod.Raw?.spec?.ephemeralContainers !== undefined) {

      pod.Raw.spec.ephemeralContainers.map(container => {
        try {
          container.image = this.imageTransformHost(
            address,
            container.image
          );
        } catch (err) {
          Log.error("Error calling imageTransformHost", err.toString());
        }
      })

    }


    pod.Raw.spec.containers.map(container => {
      try {
        container.image = this.imageTransformHost(
          address,
          container.image
        );
        Log.info(
          "Transformed image: " +
          JSON.stringify(pod.Raw.spec.containers, undefined, 2)
        );
      } catch (err) {
        Log.error("Error calling imageTransformHost", err.toString());
      }
    }
    );
  }

  imageTransformHost(
    targetHost: string,
    srcReference: string
  ): string {
    if (!this.ImageTransformHost) {
      throw new Error('WebAssembly module not loaded or initialized.');
    }
    let transformedImage: string;

    try {
      transformedImage = this.ImageTransformHost(targetHost, srcReference);
    } catch (err) {
      Log.error("Error calling imageTransformHost", err.toString());
    }
    return transformedImage
  }

  // async imageTransformHostWithoutChecksum(
  //   targetHost: string,
  //   srcReference: string
  // ): Promise<string> {
  //   const request = new TransformRequest();
  //   request.setTargethost(targetHost);
  //   request.setSrcreference(srcReference);

  //   return new Promise<string>((resolve, reject) => {
  //     this.client.imageTransformHostWithoutChecksum(
  //       request,
  //       (err, response) => {
  //         if (err) {
  //           Log.error(
  //             "Error calling imageTransformHostWithoutChecksum",
  //             err.toString()
  //           );
  //           reject(err);
  //         } else {
  //           resolve(response.getTransformedimage());
  //         }
  //       }
  //     );
  //   });
  // }
}
